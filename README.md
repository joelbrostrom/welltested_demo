# welltested_demo

A small demo of how to use welltested as of 28/10-23

## Getting Started

This demo will be divided into separate branches which represent different steps in the process.
Hopefully this will make it easy to follow along.

If you want to skip to the end simply checkout the lates branch.

## Steps

### Step 1: Setup welltested

Check out [the latest documentation](https://docs.welltested.ai/documentation/set-up) for up to date info.

1. Install the welltested cli:
```bash
dart pub global activate welltested
```

2. Either follow the instructions from the website to manually set up dependencies, or run the welltested init command to do it automatically.
```bash
welltested init
```

3. When asked in the terminal, add your API key recived in your email inbox after signing up for a free license at [Welltested.ai](https://www.welltested.ai/).

### Step 2: Generate unit tests

Now that the welltested CLI is installed and all the dependecies are set up we can start generate tests.

Lets start with the `Operations` class. This class contains no widgets and is purely logic, so it's straight forward to test.

1. Add the annotation `@Welltested()` over the class you want to test and import the package. 

    In our case it looks something like this: 
    ```dart
    import 'package:welltested_annotation/welltested_annotation.dart';

    @Welltested()
    class Operations {
    // Rest of code unchanged
    }
    ```

2. Run the command `welltested generate unit`
   
   This will start the generation of the tests.  

3. Some or all of the test might not compile after the initial generation. Do not panic, this is normal. As you use welltested the AI will learn how to build tests for your specific project. This will mean that in the begining we will have to do some manual changes.

    Since all tests are generated by AI the outcome might differ between each run, so I cannot tell you how to fix your specific tests. 
    In my case the tests generated mocked the Operations class. This is bad since this is the calss we want to test.

    Instead of fixing all the broken tests just open the first (or whichever makes most sense to you) and manually fix the tests in that file until you are happy with the result.
    Delete the other failing tests for now.

4. Save the changes made by running `welltested save unit`. This will push your changes to Welltested servers and will be used as a reference for future test generation.

5. Run `welltested generate unit` once again. It will now regenerate the deleted test cases, and you will notice that all the mistakes corrected in the first file is now auutomatically fixed in a similar way by the AI. If some problem still exist repeat step 3 to 5 untill all tests passes. 

    Remember that the longer you use the AI the more it learn, so you will graduatly have to do less and less manual changes over time.

You should now have a folder called `operations` in your test path containing one file for each method in the `Operations` class. You might also have some generated mock files if your test implementation uses mocked classes. 

### Step 3: Testcase annotations

Now that we have our tests we can look at them and see if something is missing. In my case one test for isPrime looked like this: 

```dart
 test('isPrime should return true for prime numbers', () {
      final operations = Operations();

      expect(operations.isPrime(3), true);
      expect(operations.isPrime(5), true);
      expect(operations.isPrime(7), true);
      expect(operations.isPrime(11), true);
      expect(operations.isPrime(13), true);
    });
```

It is odd that it skips the first prime number, 2. 
To fix this we can either manualy change the test, or we can use the `@Testcases` annotation to tell welltested what we want it to test. To use this annotation find the method you want to provide instructions to and:

1. Add the `@Testcases(['Test description'])` over the method you want to modify. In our case we can add something like this:

    ```dart 
    /// Returns true if [number] is prime.
    @Testcases([
    "Verify that the first 5 known primes return true",
     ])
    bool isPrime(int number) {
      if (number <= 2) return false;
      for (int i = 2; i * i <= number; i++) {
        if (number % i == 0) return false;
      }
      return true;
    }
    ```

2. Run `welltested generate unit` again. This time only the isPrime method has been change, so only this file will be regenerated. 

Once done we can see that our test was updated to the following: 

```dart
test('isPrime should return true for the first 5 known primes', () {
  final operations = Operations();

  expect(operations.isPrime(2), true);
  expect(operations.isPrime(3), true);
  expect(operations.isPrime(5), true);
  expect(operations.isPrime(7), true);
  expect(operations.isPrime(11), true);
});
```

This is great, so we run the test and to our suprice (or maybe not) it fails.
Reading the output we see that `isPrime(2)` returned false.  
The test has found a bug in our code! 

To fix this we should make the following correction:

```dart
 if (number <= 2) return false; //Before
 if (number < 2) return false; //After
```

Now we can run the tests again and all test will pass. 

We just got saved by the AI.

### Step 4: Testing Widget logic

